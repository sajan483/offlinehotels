var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
import { Directive, ViewContainerRef, TemplateRef } from '@angular/core';
import { autorun } from 'mobx';
import { MobxAutorunDirective } from './mobx-autorun.directive';
var MobxAutorunSyncDirective = /** @class */ (function (_super) {
    __extends(MobxAutorunSyncDirective, _super);
    function MobxAutorunSyncDirective(templateRef, viewContainer) {
        var _this = _super.call(this, templateRef, viewContainer) || this;
        _this.templateRef = templateRef;
        _this.viewContainer = viewContainer;
        return _this;
    }
    MobxAutorunSyncDirective.prototype.autoDetect = function (view) {
        console.warn('mobxAutorunSync is deprecated, please use mobxAutorun instead - it\'s doing exactly the same thing');
        this.dispose = autorun(function () {
            view['detectChanges']();
        });
    };
    MobxAutorunSyncDirective.decorators = [
        { type: Directive, args: [{ selector: '[mobxAutorunSync]' },] },
    ];
    /** @nocollapse */
    MobxAutorunSyncDirective.ctorParameters = function () { return [
        { type: TemplateRef, },
        { type: ViewContainerRef, },
    ]; };
    return MobxAutorunSyncDirective;
}(MobxAutorunDirective));
export { MobxAutorunSyncDirective };

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibW9ieC1hdXRvcnVuLXN5bmMuZGlyZWN0aXZlLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vbGliL2RpcmVjdGl2ZXMvbW9ieC1hdXRvcnVuLXN5bmMuZGlyZWN0aXZlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBQSxPQUFPLEVBQUUsU0FBUyxFQUFFLGdCQUFnQixFQUFFLFdBQVcsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUN6RSxPQUFPLEVBQUUsT0FBTyxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQy9CLE9BQU8sRUFBQyxvQkFBb0IsRUFBQyxNQUFNLDBCQUEwQixDQUFDOztJQUdoQiw0Q0FBb0I7SUFDaEUsa0NBQ1ksV0FBNkIsRUFDN0IsYUFBK0I7UUFGM0MsWUFFOEMsa0JBQU0sV0FBVyxFQUFFLGFBQWEsQ0FBQyxTQUFHO1FBRHRFLGlCQUFXLEdBQVgsV0FBVyxDQUFrQjtRQUM3QixtQkFBYSxHQUFiLGFBQWEsQ0FBa0I7O0tBQXVDO0lBRWxGLDZDQUFVLEdBQVYsVUFBVyxJQUFJO1FBQ2IsT0FBTyxDQUFDLElBQUksQ0FBQyxvR0FBb0csQ0FBQyxDQUFDO1FBRW5ILElBQUksQ0FBQyxPQUFPLEdBQUcsT0FBTyxDQUFDO1lBQ3JCLElBQUksQ0FBQyxlQUFlLENBQUMsRUFBRSxDQUFDO1NBQ3pCLENBQUMsQ0FBQztLQUNKOztnQkFaRixTQUFTLFNBQUMsRUFBRSxRQUFRLEVBQUUsbUJBQW1CLEVBQUU7Ozs7Z0JBSk4sV0FBVztnQkFBN0IsZ0JBQWdCOzttQ0FBcEM7RUFLOEMsb0JBQW9CO1NBQXJELHdCQUF3QiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERpcmVjdGl2ZSwgVmlld0NvbnRhaW5lclJlZiwgVGVtcGxhdGVSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IGF1dG9ydW4gfSBmcm9tICdtb2J4JztcbmltcG9ydCB7TW9ieEF1dG9ydW5EaXJlY3RpdmV9IGZyb20gJy4vbW9ieC1hdXRvcnVuLmRpcmVjdGl2ZSc7XG5cbkBEaXJlY3RpdmUoeyBzZWxlY3RvcjogJ1ttb2J4QXV0b3J1blN5bmNdJyB9KVxuZXhwb3J0IGNsYXNzIE1vYnhBdXRvcnVuU3luY0RpcmVjdGl2ZSBleHRlbmRzIE1vYnhBdXRvcnVuRGlyZWN0aXZlIHtcbiAgY29uc3RydWN0b3IoXG4gICAgcHJvdGVjdGVkIHRlbXBsYXRlUmVmOiBUZW1wbGF0ZVJlZjxhbnk+LFxuICAgIHByb3RlY3RlZCB2aWV3Q29udGFpbmVyOiBWaWV3Q29udGFpbmVyUmVmKSB7c3VwZXIodGVtcGxhdGVSZWYsIHZpZXdDb250YWluZXIpOyB9XG5cbiAgYXV0b0RldGVjdCh2aWV3KSB7XG4gICAgY29uc29sZS53YXJuKCdtb2J4QXV0b3J1blN5bmMgaXMgZGVwcmVjYXRlZCwgcGxlYXNlIHVzZSBtb2J4QXV0b3J1biBpbnN0ZWFkIC0gaXRcXCdzIGRvaW5nIGV4YWN0bHkgdGhlIHNhbWUgdGhpbmcnKTtcblxuICAgIHRoaXMuZGlzcG9zZSA9IGF1dG9ydW4oKCkgPT4ge1xuICAgICAgdmlld1snZGV0ZWN0Q2hhbmdlcyddKCk7XG4gICAgfSk7XG4gIH1cbn1cbiJdfQ==