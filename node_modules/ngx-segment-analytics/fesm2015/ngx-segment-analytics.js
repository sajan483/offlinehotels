import * as i0 from '@angular/core';
import { InjectionToken, Injectable, Inject, NgModule, PLATFORM_ID, Optional, SkipSelf } from '@angular/core';
import * as i2 from '@angular/common';
import { DOCUMENT, isPlatformBrowser, CommonModule } from '@angular/common';

/** Segment Configuration Injection Token */
const SEGMENT_CONFIG = new InjectionToken('ngx-segment-analytics.config');
const DEFAULT_CONFIG = {
    debug: false,
    loadOnInitialization: true,
    segmentHost: 'cdn.segment.com',
    segmentUri: '/analytics.js/v1/$API_KEY$/analytics.min.js',
};

/**
 * Window Wrapper for Angular AOT
 */
class WindowWrapper {
}
WindowWrapper.decorators = [
    { type: Injectable }
];

class SegmentService {
    /**
     * @param _w Browser window
     * @param _doc Browser DOM
     * @param userConfig Segment configuration
     */
    constructor(_w, _doc, userConfig) {
        this._w = _w;
        this._doc = _doc;
        this._config = Object.assign(Object.assign({}, DEFAULT_CONFIG), userConfig);
        if (this._config.loadOnInitialization && (typeof this._config.apiKey === 'undefined' || this._config.apiKey === '')) {
            console.error('The API Key cannot be an empty string if Segment must be loaded on initialization.');
            return;
        }
        if (typeof this._w.analytics === 'undefined'
            || typeof this._w.analytics.initialize === 'undefined'
            || this._w.analytics.initialize === false) {
            if (typeof this._w.analytics !== 'undefined' && this._w.analytics.invoked === true) {
                console.error('Segment snippet included twice.');
                return;
            }
            if (this._config.debug) {
                console.log('Segment initialization...');
            }
            this._w.analytics = [];
            this._w.analytics.invoked = true;
            this._w.analytics.methods = [
                'trackSubmit',
                'trackClick',
                'trackLink',
                'trackForm',
                'pageview',
                'identify',
                'reset',
                'group',
                'track',
                'ready',
                'alias',
                'debug',
                'page',
                'once',
                'off',
                'on',
                'addSourceMiddleware',
                'addIntegrationMiddleware',
                'setAnonymousId',
                'addDestinationMiddleware',
            ];
            this._w.analytics.factory = (method) => {
                return (...args) => {
                    args.unshift(method);
                    this._w.analytics.push(args);
                    return this._w.analytics;
                };
            };
            this._w.analytics.methods.forEach((method) => {
                this._w.analytics[method] = this._w.analytics.factory(method);
            });
            this._w.analytics.load = (key, options) => {
                const script = this._doc.createElement('script');
                script.type = 'text/javascript';
                script.async = true;
                script.src = 'https://' + this._config.segmentHost + this._config.segmentUri.replace('$API_KEY$', key);
                const first = this._doc.getElementsByTagName('script')[0];
                first.parentNode.insertBefore(script, first);
                this._w.analytics._loadOptions = options;
            };
            this._w.analytics._writeKey = this._config.apiKey;
            this._w.analytics.SNIPPET_VERSION = '4.13.2';
            if (this._config.loadOnInitialization) {
                this.load(this._config.apiKey);
            }
        }
    }
    /**
     * Load Segment configuration.
     *
     * @param apiKey Write API Key
     * @param options Optional parameters
     */
    load(apiKey, options) {
        this._w.analytics.load(apiKey, options);
        if (this._config.debug) {
            console.log('Segment initialized');
        }
        this.debug(this._config.debug);
    }
    /**
     * The identify method is how you associate your users and their actions to a recognizable userId and traits.
     *
     * @param userId The database ID for the user.
     * @param traits A dictionary of traits you know about the user, like their email or name
     * @param options A dictionary of options.
     *
     * @returns
     */
    identify(userId, traits, options) {
        return new Promise((resolve) => {
            this._w.analytics.identify(userId, traits, options, _ => resolve(this));
        });
    }
    /**
     * The track method lets you record any actions your users perform.
     *
     * @param event The name of the event you’re tracking.
     * @param properties A dictionary of properties for the event.
     * @param options A dictionary of options.
     *
     * @returns
     */
    track(event, properties, options) {
        return new Promise((resolve) => {
            this._w.analytics.track(event, properties, options, _ => resolve(this));
        });
    }
    /**
     * The page method lets you record page views on your website, along with optional extra information about the page being viewed.
     *
     * @param category The category of the page.
     * @param name The name of the page.
     * @param properties A dictionary of properties of the page.
     * @param options A dictionary of options.
     *
     * @returns
     */
    page(category, name, properties, options) {
        return new Promise((resolve) => {
            this._w.analytics.page(category, name, properties, options, _ => resolve(this));
        });
    }
    /**
     * The group method associates an identified user with a company, organization, project, workspace, team, tribe, platoon,
     * assemblage, cluster, troop, gang, party, society or any other name you came up with for the same concept.
     *
     * @param groupId The Group ID to associate with the current user.
     * @param traits A dictionary of traits for the group.
     *
     * @returns
     */
    group(groupId, traits) {
        return new Promise((resolve) => {
            this._w.analytics.group(groupId, traits, _ => resolve(this));
        });
    }
    /**
     * The alias method combines two previously unassociated user identities.
     *
     * @param userId The new user ID you want to associate with the user.
     * @param previousId The previous ID that the user was recognized by. This defaults to the currently identified user’s ID.
     * @param options A dictionary of options.
     *
     * @returns
     */
    alias(userId, previousId, options) {
        return new Promise((resolve) => {
            this._w.analytics.alias(userId, previousId, options, _ => resolve(this));
        });
    }
    /**
     * The ready method allows you execute a promise that will be called as soon as all of your enabled destinations have loaded
     * and analytics.js has completed initialization.
     *
     * @returns
     */
    ready() {
        return new Promise((resolve) => {
            this._w.analytics.ready(_ => resolve(this));
        });
    }
    /**
     * Return informations about the currently identified user
     *
     * @returns Informations about the currently identified user
     */
    user() {
        return this._w.analytics.user();
    }
    /**
     * Return identifier about the currently identified user
     *
     * @returns Identifier about the currently identified user
     */
    id() {
        return this._w.analytics.id();
    }
    /**
     * Override the default Anonymous ID
     *
     * @param anonymousId New anonymous ID
     */
    setAnonymousId(anonymousId) {
        this._w.analytics.setAnonymousId(anonymousId);
    }
    /**
     * Return traits about the currently identified user
     *
     * @returns Traits about the currently identified user
     */
    traits() {
        return this._w.analytics.user().traits();
    }
    /**
     * Reset the id, including anonymousId, and clear traits for the currently identified user and group.
     */
    reset() {
        this._w.analytics.reset();
    }
    /**
     * Turn on/off debug mode, logging helpful messages to the console.
     *
     * @param enabled Enable or not the debug mode
     */
    debug(enabled) {
        this._w.analytics.debug(enabled);
    }
    /**
     * Set listeners for these events and run your own custom code.
     *
     * @param method Name of the method to listen for
     * @param callback A function to execute after each the emitted method
     */
    on(method, callback) {
        this._w.analytics.on(method, callback);
    }
    /**
     * Attaches the `track` call as a handler to a link
     *
     * @param elements DOM element or an array of DOM elements to be bound with track method.
     * @param event The name of the event, passed to the `track` method or a function that returns a string to be used
     *              as the name of the track event.
     * @param properties A dictionary of properties to pass with the `track` method.
     */
    trackLink(elements, event, properties) {
        this._w.analytics.trackLink(elements, event, properties);
    }
    /**
     * Binds a `track` call to a form submission.
     *
     * @param forms The form element to track or an array of form
     * @param event The name of the event, passed to the `track` method.
     * @param properties A dictionary of properties to pass with the `track` method.
     */
    trackForm(forms, event, properties) {
        this._w.analytics.trackForm(forms, event, properties);
    }
    /**
     * Set the length (in milliseconds) of the callbacks and helper functions
     *
     * @param timeout Number of milliseconds
     */
    timeout(timeout) {
        this._w.analytics.timeout(timeout);
    }
    /**
     * Add a source middleware called on events
     *
     * @param middleware Custom function
     */
    addSourceMiddleware(middleware) {
        this._w.analytics.addSourceMiddleware(middleware);
    }
    /**
     * Add a destination middleware called on events
     *
     * @param integration Integration name
     * @param middlewares Custom functions
     */
    addDestinationMiddleware(integration, middlewares) {
        this._w.analytics.addDestinationMiddleware(integration, middlewares);
    }
    get plugins() {
        return this._w.analytics.plugins;
    }
}
SegmentService.ɵprov = i0.ɵɵdefineInjectable({ factory: function SegmentService_Factory() { return new SegmentService(i0.ɵɵinject(WindowWrapper), i0.ɵɵinject(i2.DOCUMENT), i0.ɵɵinject(SEGMENT_CONFIG)); }, token: SegmentService, providedIn: "root" });
SegmentService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root',
            },] }
];
SegmentService.ctorParameters = () => [
    { type: WindowWrapper, decorators: [{ type: Inject, args: [WindowWrapper,] }] },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: undefined, decorators: [{ type: Inject, args: [SEGMENT_CONFIG,] }] }
];

/**
 * Window Provider for Angular AOT
 * @returns Browser Window instance
 */
function getWindow(platformId) {
    return isPlatformBrowser(platformId) ? window : {};
}
/**
 * Segment Module
 */
class SegmentModule {
    /**
     * Segment Module Constructor
     *
     * @param parentModule Must be null
     */
    constructor(parentModule) {
        if (parentModule) {
            throw new Error('SegmentModule is already loaded. Import it in the AppModule only');
        }
    }
    /**
     * Segment Module Initialisation
     *
     * @param config Segment Configuration
     * @returns Segment Module
     */
    static forRoot(config) {
        return {
            ngModule: SegmentModule,
            providers: [
                { provide: SEGMENT_CONFIG, useValue: config },
                SegmentService,
            ],
        };
    }
}
SegmentModule.decorators = [
    { type: NgModule, args: [{
                imports: [CommonModule],
                providers: [
                    { provide: WindowWrapper, useFactory: getWindow, deps: [PLATFORM_ID] },
                ]
            },] }
];
SegmentModule.ctorParameters = () => [
    { type: SegmentModule, decorators: [{ type: Optional }, { type: SkipSelf }] }
];

/**
 * Generated bundle index. Do not edit.
 */

export { DEFAULT_CONFIG, SEGMENT_CONFIG, SegmentModule, SegmentService, WindowWrapper, getWindow };
//# sourceMappingURL=ngx-segment-analytics.js.map
